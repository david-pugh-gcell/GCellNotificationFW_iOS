{
  "name": "Gcellnotificationfw ios",
  "tagline": "Example Swift code using the GCell iBeacon Notification FW to easily set up and detect proximity to nearby iBeacons.",
  "body": "# GCellNotificationFW for iOS\r\nThis project is an example XCode project that uses the GCell iBeacon Notification FW to easily set up and detect proximity to nearby iBeacons. It is written in Swift (XCode 7.3).\r\n\r\nFor more information about iBeacons, potential applications, the Framework and other software support such as platforms please contact us at [GCell ibeacon.solar](www.ibeacon.solar).\r\n\r\nLatest version: v1_1 (06 July 2016)\r\n\r\n<h2>Full Documentation</h2>\r\nFor full documentation please see the repository [docs](https://htmlpreview.github.io/?https://raw.githubusercontent.com/david-pugh-gcell/GCellNotificationFW_iOS/master/docs/Classes/GCBeaconManager.html).\r\n\r\n<h3>Description</h3>\r\n\r\nThis is an example XCode iOS app written in Swift that uses the GCellNotificationFW Cocoa Touch Framework. This framework allows the developer to quickly and easily integrate iBeacon proximity awareness into their app with the minimal of code. It can be used to return any nearby ranged iBeacons in foreground and background modes, or can be configured to call custom actions within the app when the beacon signal strength is greater than a certain figure and a defined ammount of time has passed. The Framework automatically manages permissions, detecting Bluetooth state and manages Beacon Regions. \r\n\r\n<h3>Using the Framework</h3>\r\n\r\nImporting the Framework into your XCode Project\r\n1. Drag the GCellNotificationFWv1_1 framework into your XCode Project\r\n2. Click on your project target ->General and also add the framework to the Embedded Binaries\r\n3. Clean and rebuild the project - the classes in the framework should now be avilable to use\r\n\r\n<h4>Setting up your Project to work with iBeacons</h4>\r\nWe need to add a few settings to your project to enable it to successfully see iBeacons. \r\n\r\n1. Open the info.plist file and add an entry for <i>NSLocationAlwaysUsageDescription</i>. This is shown when the app asks the user to have permissions to use location services to scan for nearby beacons. Add a sensible string that informs the user what we need the permissions for, e.g., \"This app needs access to your location to send you relevant notifications and offers.\"\r\n2. Click on the Project -> Targets - Project Target and select the Capablities option. Scroll down and enable <i>Background Modes</i>. Click on to select the <i> Uses Bluetooth LE accessory</i> checkbox. These allow the app to search for iBeacons using Bluetooth Low Energy when the app is in the background. \r\n\r\n**Your app is now ready to scan for iBeacons!** \r\n\r\n<h4>Telling the app what to Search for</h4>\r\nThere are two ways in which the framework can be used - either configured to operate like the standard iOS iBeacon framework in CoreLocation, or using a 'AutoNotify' option. This auto notify options allows the user to easily supply a list of beacons in JSON format, and associate actions that get called when the beacon is ranged. The user can also adjust the signal strength and timings of when these actions are triggered.\r\n\r\n<h4>Using Auto-notify</h4>\r\nFirstly, create a list of which beacons you want to scan for, along with any actions and store them in the following JSON file. The file should be called **beacons.json** and included in your project. \r\n\r\n* The **actionName** is the string that is called when the action is triggered\r\n* The **minActionRssi** determines the min Signal Strength (RSSI) that the phone should see before triggering the action (the higher the number the closer you will be to the beacon, e.g., -90dB would be approx 20m and -40dB would be 5m). \r\n* The **reccurance** value is the time in seconds between subsequent triggers. E.g., a value of 300 would mean the time between multiple actionName triggers would be 5 minutes (300 seconds). This means we can control the ammount of times a user would be presented with information or notifications, improving user experience. \r\n\r\n```json\r\n{\r\n    \"beacons\":[\r\n               {\r\n               \"comment\":\"Example 1\",\r\n               \"UUID\":\"A36AD2B5-0736-43FB-8572-63DB53886FF3\",\r\n               \"major\":200,\r\n               \"minor\":108,\r\n               \"actions\":   [\r\n                             {\r\n                             \"actionName\":\"custom1\",\r\n                             \"minActionRssi\": -55,\r\n                             \"recurrance\": 5\r\n                             },\r\n                             {\r\n                             \"actionName\":\"custom3\",\r\n                             \"minActionRssi\": -55,\r\n                             \"recurrance\": 10\r\n                             }\r\n                             \r\n                             ]\r\n               },\r\n               {\r\n               \"comment\":\"Example 2\",\r\n               \"UUID\":\"96530d4d-09af-4159-b99e-951a5e826584\",\r\n               \"major\":100,\r\n               \"minor\":1,\r\n               \"actions\":   [\r\n                             {\r\n                             \"actionName\":\"custom2\",\r\n                             \"minActionRssi\": -55,\r\n                             \"recurrance\": 20\r\n                             }\r\n                             ]\r\n               }\r\n               \r\n               ]\r\n}\r\n```\r\n\r\n<h4>Starting the Scan</h4>\r\nFirstly declare a GCBeaconManager as an instance variable.\r\n\r\n```Swift\r\nvar beaconManager = GCBeaconManager()\r\n```\r\n\r\nEnsure that the class adopts the GCBeaconManagerDelegate protocol in its definition. Then set the delegate, switch on/off debugging, set autonotify to true and start scanning. \r\n\r\n```Swift\r\nbeaconManager.debug = true\r\nbeaconManager.delegate = self\r\nbeaconManager.autoNotify = true\r\nbeaconManager.useDefaultBeaconRegion = false\r\nbeaconManager.startScanningForBeacons()\r\n```\r\n\r\nThe app will chack permissions and settings, load up the beacons data, autoconfigure beacon regions and start scanning. It will return triggered actions and any error feedback messages through the GCBeaconManagerDelegate protocol.\r\n\r\n```Swift\r\n //You can either react to the list of beacons that are in the notification list and in range, or just the list of actions associated with those beacons\r\n    \r\n    //These are the beacons that were ranged as part of the notification system\r\n    func beaconManager(beaconManager: GCBeaconManager, didRangeNotificationBeacons beacons: [GCBeacon]){\r\n        print(\"Ranged the following listed beacons:\")\r\n        for b in beacons{\r\n            print(\"\\(b.major)/\\(b.minor) with \\(b.lastKnownRssi)dB at \\(b.lastSeen)\")\r\n        }\r\n        \r\n    }\r\n    \r\n    //These are the custom action calls as part of the notification system\r\n    func beaconManager(beaconManager: GCBeaconManager, didReceiveNotificationActions actions: Set<GCBeaconAction>) {\r\n        print(\"Actions Received:\")\r\n        for a in actions{\r\n            print(\"\\(a.actionName)\")\r\n        }\r\n    }\r\n    \r\n    //Handle any feedback received from framework\r\n     func beaconManager(beaconManager: GCBeaconManager, errorCode: Int, with errorMessage: String) {\r\n        print(\"Error! \\(error) - \\(errorDesc)\")\r\n    }\r\n\r\n```\r\n\r\n<h4>Using Standard Scan</h4>\r\nThis sets the app to run like a normal iOS project using CoreLocation, except permissions and Bluetooth status is handled automatically. You can also use the default GCell UUID without having to enter any UUID details. Set up the instance variable and protocol adoption as above, and also remember to set the delegate. Set autoNotify to false and then set up the Beacon Regions you wish to monitor and add them to the beaconManager. \r\n\r\n```Swift\r\n //set the auto notify function OFF\r\n                beaconManager.autoNotify = false\r\n                beaconManager.debug = true\r\n                beaconManager.delegate = self\r\n                \r\n                //Set up beacon regions\r\n                let uuidString = \"A36AD2B5-0736-43FB-8572-63DB53886FF3\"\r\n                let beaconIdentifier = \"iBeaconModules.us\"\r\n                let beaconUUID:NSUUID = NSUUID(UUIDString: uuidString)!\r\n                let beaconRegion:CLBeaconRegion = CLBeaconRegion(proximityUUID: beaconUUID, identifier: beaconIdentifier)\r\n \r\n                //Add the regions\r\n                beaconManager.addBeaconRegion(beaconRegion) //Leave this out to use the default GCell UUID as the beacon region\r\n                \r\n                //Start Scanning\r\n                beaconManager.startScanningForBeacons()\r\n```\r\n\r\nRespond to the beacons ranged delegate call back. \r\n\r\n```Swift\r\n    //Handle any feedback received from framework\r\n    func beaconManager(beaconManager: GCBeaconManager, errorCode: Int, with errorMessage: String) {\r\n        print(\"Error! \\(error) - \\(errorDesc)\")\r\n    }\r\n    \r\n    \r\n    //Handel didRanging calls\r\n    func beaconManager(beaconManager: GCBeaconManager, didRangeBeacons beacons: [CLBeacon], inRegion region: CLBeaconRegion) {\r\n            print(\"Ranged the following beacons in region \\(region):\")\r\n            for b in beacons{\r\n                print(\"\\(b.major)/\\(b.minor) with \\(b.rssi)dB\")\r\n            }\r\n    }\r\n\r\n```\r\n\r\n<h3>Background Mode</h3>\r\nThe framework will follow Apple guidelines for working in background mode. The ranging function of the app is extended to improve accuracy once a beacon region is detected, but this is only for a short time to minimise battery use. It should be enough for many applications. This Framework is not intended to be used for a navigation based app requiring continal ranging whilst in background mode - if you require this please contact us to discuss this. The app doesnt automatically deliver local notifications, just the callback to say the beacon has been ranged/action has been trigger. It is left to the developer to implement any notifications to the user. Again - any queries or requests please do not hesitate to contact us to see how we can help.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}